[{"content":"vm 虚拟机，vm 模块使能够在 V8 虚拟机上下文中编译和运行代码。\nJavaScript 代码可以被立即地编译并且运行，或者编译、保存并且稍后运行。\n一个例子 1 2 3 4 5 6  const vm = require(\u0026#39;vm\u0026#39;); const code = \u0026#39;console.log(\u0026#34;1\u0026#34;);\u0026#39;; const script = new vm.Script(code); script.runInThisContext();   复用字节码 JavaScript 代码编译成字节码，通过二进制存储起来，稍后运行。\n编译成字节码:\n1 2 3 4 5 6 7 8 9 10  const vm = require(\u0026#39;vm\u0026#39;); const code = `console.log(\u0026#34;1\u0026#34;);`; const script = new vm.Script(code, { produceCachedData: true // 需要指定 produceCachedData 为 true }); // script.cachedData 为字节码 buffer const bytecodeBuffer = script.cachedData; // 可以将 bytecodeBuffer 保存成一个二进制文件   使用字节码:\n1 2 3 4 5 6 7 8  // 先获取 bytecodeBuffer  const anotherScript = new vm.Script(\u0026#39; \u0026#39;.repeat(code.length), { cachedData: bytecodeBuffer // 指定字节码 }); anotherScript.runInThisContext();   注意，这里 vm.Script 第一个参数可以传空字符串，但长度必须和之前的代码长度一致。\n创建 vm.Script 实例时，V8 会检查字节码（cachedData）是否与源代码（第一个参数传入的代码）匹配，如果匹配就跳过编译过程，所以第一个参数不能省略。其次，这个检查非常简单，它只会对比代码长度是否一致，所以只要使用与源代码长度相同的空格，就可以“欺骗”这个检查。\nrunInContext vs runInNewContext vs runInThisContext 首先它们的作用是一样的，执行 vm.Script 对象里被编译的代码并返回其结果，被执行的代码都无法获取本地作用域。\n1 2 3 4 5 6 7 8  const vm = require(\u0026#39;vm\u0026#39;); const code = \u0026#39;console.log(a);\u0026#39;; const script = new vm.Script(code); const a = 1; // 本地作用域变量 script.runInThisContext(); // 报错 script.runInContext(); // 报错 script.runInNewContext(); // 报错   runInThisContext 能获取 global 对象。\n1 2 3 4 5 6  const vm = require(\u0026#39;vm\u0026#39;); const code = \u0026#39;console.log(a);\u0026#39;; const script = new vm.Script(code); global.a = 1; // golbal对象变量 script.runInThisContext();   runInContext 无法获取本地作用域，也不能获取 global 对象，但是可以传入一个对象作为上下文 context。\n1 2 3 4 5 6 7 8 9 10 11 12  const vm = require(\u0026#39;vm\u0026#39;); const code = \u0026#39;console.log(a);\u0026#39;; const script = new vm.Script(code); const context = { a: 1, console }; vm.createContext(context); // conext需要传给vm.createContext处理 script.runInContext(context);   在code中，对全局变量进行修改，会体现在 context 对象中：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14  const vm = require(\u0026#39;vm\u0026#39;); const code = \u0026#39;a++\u0026#39;; const script = new vm.Script(code); const context = { a: 1, }; vm.createContext(context); // conext需要传给vm.createContext处理 script.runInContext(context); console.log(context.a); // 2   runInNewContext runInNewContext的源代码如下，它不过是对runInContext调用的简化。\n1 2 3 4  runInNewContext(contextObject, options) { const context = createContext(contextObject, getContextOptions(options)); return this.runInContext(context, options); }   例：\n1 2 3 4 5 6 7 8 9 10  const vm = require(\u0026#39;vm\u0026#39;); const code = \u0026#39;console.log(a);\u0026#39;; const script = new vm.Script(code); const context = { a: 1, console }; script.runInNewContext(context); // 因为不能获取 global 对象，所以 console 也需要传入。   ","description":"","id":0,"section":"posts","tags":null,"title":"Node中vm模块的使用","uri":"https://lulupy.github.io/posts/pkg%E5%B0%86node%E9%A1%B9%E7%9B%AE%E6%89%93%E5%8C%85%E6%88%90%E5%8F%AF%E6%89%A7%E8%A1%8C%E6%96%87%E4%BB%B6/content/node%E4%B8%ADvm%E6%A8%A1%E5%9D%97%E7%9A%84%E4%BD%BF%E7%94%A8/"},{"content":"当我们调用require(...)， 它到底是怎么样的一个过程？\nrequire(\u0026hellip;) 加载模块 1  const mod = require(\u0026#39;./a.js\u0026#39;);   通过跟踪代码，探究一下背后的过程。 注意，下面的代码经过严重简化。\n1. require函数 1 2 3  require = function require(path) { return mod.require(path); };   2. mod.require函数 1 2 3  Module.prototype.require = function(id) { return Module._load(id, this, /* isMain */ false); };   3. Module._load函数 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19  Module._load = function(request, parent, isMain) { // 获取文件路径  const filename = Module._resolveFilename(request, parent, isMain); // 原生模块对象  if (NativeModule.nonInternalExists(filename)) { debug(\u0026#39;load native module %s\u0026#39;, request); return NativeModule.require(filename); } // 第三方模块创建模块对象，包括node_modules下和src下的  var module = new Module(filename, parent); // 加载模块  module.load(filename); return module.exports; }   Module._resolveFilename 函数的作用是找到文件路径。\nModule._resolveFilename 函数依赖父模块 parent， 比如父模块的路径为 /project/src/index.js， 那么 require('./a.js') 是相对于父模块的路径来查找的：\nrequire('./a') \u0026ndash;\u0026gt; /project/src/a.js\nrequire(\u0026lsquo;express\u0026rsquo;) \u0026ndash;\u0026gt; /project/node_modules/express/index.js\n\u0026hellip;\n以 require('express') 为例，将会以如下顺序查找文件，如果文件存在则返回文件决定路径：\n node_modules/express.js node_modules/express.json node_modules/express.node node_modules/express/package.json 返回main字段指定文件 node_modules/express/index.js  4. mod.load函数 1 2 3 4  Module.prototype.load = function(filename) { const extension = findLongestRegisteredExtension(filename); Module._extensions[extension](this, filename); }   根据文件后缀执行不同的操作，比如 .js、.json、.node()，json 文件会直接读取文件内容，JSON.parse 直接输出， node 文件会使用 process.dlopen() 执行文件。\n5. 对js文件处理的部分 1 2 3 4  Module._extensions[\u0026#39;.js\u0026#39;] = function(module, filename) { content = fs.readFileSync(filename, \u0026#39;utf8\u0026#39;); module._compile(content, filename); }   对于 js 文件，先读取 js 代码内容，然后编译代码。\n6. mod._compile函数 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16  Module.prototype._compile = function(content, filename) { var wrapper = Module.wrap(content); var compiledWrapper = vm.runInThisContext(wrapper, { filename: filename, lineOffset: 0, displayErrors: true }); compiledWrapper.call( this.exports, this.exports, // 模块代码运行会在this.exports上添加变量，这个也是require(...)返回的结果  require, this, filename, dirname ); }   编译代码主要用到 vm 模块，将代码编译成字节码，让v8虚拟机运行。\nModule.wrap 1 2 3 4 5  const Module = require(\u0026#39;module\u0026#39;); Module.wrap(\u0026#39;console.log(1);\u0026#39;); // (function (exports, require, module, __filename, __dirname) { console.log(1); // });   Module.wrap的作用就是给代码外包裹一个函数。\n所以我们在写 nodejs 代码时可以直接使用 exports、require、module、__filename、__dirname 而不需要 require， 因为它们已经被传入。\nvm.runInThisContext vm.runInThisContext(...) 相当于 script = vm.Script(...); script.runInThisContext(...) 的组合。\nmain模块的加载 当我们运行node index.js， 会调用runMain函数:\n1 2 3 4 5  // lib/internal/modules/run_main.js  function executeUserEntryPoint(main = process.argv[1]) { Module._load(main, null, true); }   在内部直接调用 Module._load，因为它是第一个被调用的模块，所以参数 parent 为 null, isMain 为 true。\n参考链接:\n node模块加载机制  ","description":"","id":1,"section":"posts","tags":null,"title":"Node模块加载机制","uri":"https://lulupy.github.io/posts/pkg%E5%B0%86node%E9%A1%B9%E7%9B%AE%E6%89%93%E5%8C%85%E6%88%90%E5%8F%AF%E6%89%A7%E8%A1%8C%E6%96%87%E4%BB%B6/content/node%E6%A8%A1%E5%9D%97%E5%8A%A0%E8%BD%BD%E6%9C%BA%E5%88%B6/"},{"content":"如果有虚拟文件系统元数据 VIRTUAL_FILESYSTEM，并且知道 PAYLOAD_POSITION，我们就可以从pkg 打包的 exe 二进制文件中提取出 javascript 代码。 关于VIRTUAL_FILESYSTEM 和PAYLOAD_POSITION是什么，请查看 pkg原理。\n我们可以直接从 exe 文件中获取到 VIRTUAL_FILESYSTEM 和 PAYLOAD_POSITION。\n 用 vscode 打开 exe 文件 在文件底部可以看到 VIRTUAL_FILESYSTEM  搜索 \u0026lsquo;PAYLOAD_POSITION =\u0026lsquo;就可以得到PAYLOAD_POSITION。  1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62  async function extraJsFromPkgExe(exeBinary, VIRTUAL_FILESYSTEM, PAYLOAD_POSITION) { const snapshotPaths = Object.keys(VIRTUAL_FILESYSTEM); const exeBuffer = fs.readFileSync(exeBinary); for(let i=0; i\u0026lt;snapshotPaths.length; i++){ const snapshotPath = snapshotPaths[i]; if(!snapshotPath.includes(\u0026#39;node_modules\u0026#39;)){ const entityContent = VIRTUAL_FILESYSTEM[snapshotPath][1] || VIRTUAL_FILESYSTEM[snapshotPath][0]; if(entityContent) { const filePath = getRealPath(snapshotPath); const content = readFileFromVfs(entityContent); await saveFile(`./data/codes/${filePath}`, content); } else { console.log(`${snapshotPath}未找到`); } } } function readFileFromVfs(entityContent) { const [position, size] = entityContent; const buffer = Buffer.alloc(size); exeBuffer.copy(buffer, 0, PAYLOAD_POSITION + position, PAYLOAD_POSITION + position + size); return buffer; } } const getRealPath = (snapshotPath) =\u0026gt; { return snapshotPath.replace(/\\\\/g, \u0026#39;/\u0026#39;).slice(12); }; // 递归的创建目录 function mkdirsSync(dirname) { if (fs.existsSync(dirname)) { return true; } else { if (mkdirsSync(path.dirname(dirname))) { fs.mkdirSync(dirname); return true; } } } const ensureDir = (_path) =\u0026gt; { const dir = path.parse(_path).dir; if(!fs.existsSync(dir)){ mkdirsSync(dir); } }; const saveFile = (filePath, buffer) =\u0026gt; { return new Promise((resolve, reject) =\u0026gt; { const source = intoStream(buffer); ensureDir(filePath); const dest = fs.createWriteStream(filePath); source.pipe(dest); dest.on(\u0026#39;close\u0026#39;, resolve); source.on(\u0026#39;error\u0026#39;, reject); }); };   ","description":"","id":2,"section":"posts","tags":null,"title":"从exe文件中提取源码","uri":"https://lulupy.github.io/posts/pkg%E5%B0%86node%E9%A1%B9%E7%9B%AE%E6%89%93%E5%8C%85%E6%88%90%E5%8F%AF%E6%89%A7%E8%A1%8C%E6%96%87%E4%BB%B6/content/%E4%BB%8Eexe%E6%96%87%E4%BB%B6%E4%B8%AD%E6%8F%90%E5%8F%96%E6%BA%90%E7%A0%81/"},{"content":"我们直接从使用pkg打包之后的二进制文件看起。\n如上图所示，在 node 后添加了 虚拟文件系统 和 prelude.js 共同组成了打包文件。\n这里的 node 不是官方提供的二进制可执行node文件，而是经过修改了的，具体修改内容请查看 pkg-fetch/patches。\n修改 node 的主要目的是让 node 在启动阶段运行 prelude.js； 在 prelude.js 中， 修改 fs.readFile 等跟文件读写相关函数，如果文件路径是以 C:\\snapshot 开始的，就从虚拟文件系统中获取。\n虚拟文件系统 虚拟文件系统元数据 VIRTUAL_FILESYSTEM 会作为参数传递给 prelude 函数使用，如下面代码所示。\n1 2 3 4  // prelude.js function prelude(REQUIRE_COMMON, VIRTUAL_FILESYSTEM, DEFAULT_ENTRYPOINT, SYMLINKS){ ... }   VIRTUAL_FILESYSTEM 是一个 json 对象，我们来看一下一个例子。\n1 2 3 4 5 6 7 8 9 10 11 12 13 14  VIRTUAL_FILESYSTEM = { \u0026#34;C:\\\\snapshot\\\\helloworld\\\\index.js\u0026#34;: { \u0026#34;0\u0026#34;: [0, 656], \u0026#34;3\u0026#34;: [656, 118] }, \u0026#34;C:\\\\snapshot\\\\helloworld\u0026#34;: { \u0026#34;2\u0026#34;: [774, 12], \u0026#34;3\u0026#34;: [786, 117] }, \u0026#34;C:\\\\snapshot\u0026#34;: { \u0026#34;2\u0026#34;: [903, 14], \u0026#34;3\u0026#34;: [917, 117] } }   每个文件或者目录作为对象的键，每个文件或者目录都是以 C:\\\\snapshot 开头，根据这个我们判断一个文件是在虚拟文件系统中还是在本地文件系统中，根据文件或目录名我们就可以获取该文件在虚拟文件系统中存储的位置信息。\n具体的，每个文件的元数据也是一个对象，它的键名可以为 \u0026ldquo;0\u0026rdquo;、\u0026ldquo;1\u0026rdquo;、 \u0026ldquo;2\u0026rdquo;、 \u0026ldquo;3\u0026rdquo;，我在prelude.js中找到如下常量的定义。\n1 2 3 4  STORE_BLOB = 0; // 二进制文件, 字节码 STORE_CONTENT = 1; // 文本文件 STORE_LINKS = 2; // 链接文件 STORE_STAT = 3; // 文件stat   \u0026ldquo;0\u0026quot;表示 该记录 记录的是这个js文件编译之后的字节码。\n\u0026ldquo;1\u0026quot;表示 该记录 记录的是这个js文件的 javascript源代码。\n\u0026ldquo;2\u0026quot;表示 该记录 记录的是这个js文件的link信息。\n\u0026ldquo;3\u0026quot;表示 该记录 记录的是这个js文件的stat信息， 调用 fs.stat 函数的返回结果。\n每条记录， 如 [0, 656]，数组中第一个元素表示该文件在虚拟文件系统中的起始位置， 第二个元素表示该文件的大小。\n[0, 656] \u0026ndash;\u0026gt; [position, size]， index.js 在整个二进制文件的存储位置如下图所示。\n当然，我们还需要知道 node 的大小才能定位到虚拟文件系统的开始位置，我们管这个位置叫 PAYLOAD_POSITION，如下图所示。\n使用虚拟文件系统 在开始之前，我们需要一些前置知识:\n node中vm模块的使用 node模块加载机制  pkg的打包原理简单来说，就是将js代码(源代码或字节码)以及相关的资源文件打包到可执行文件中，然后劫持fs里面的一些函数，使它能够读到可执行文件中的代码和资源文件。\n在 node模块加载机制 有提到，模块加载时读取javascript代码文件 使用的是 fs.readFileSync 函数。 在 prelude.js 中，对它进行了修改。\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17  const ancestor = { readFileSync: fs.readFileSync, // 保存原来的 fs.readFileSync 函数  ... } fs.readFileSync = function(path_, options_){ // 如果文件路径不是以 C:\\\\snapshot 开头，就使用原始的 fs.readFileSync  if (!insideSnapshot(path_)) { return ancestor.readFileSync.apply(fs, arguments); } // 如果文件路径以 C:\\\\snapshot 开头，则从虚拟文件系统中获取  let buffer = readFileFromSnapshot(path_); return buffer; } ...   在 prelude.js 中，修改 Module.runMain 函数，主模块文件从虚拟文件系统中获取:\n1 2 3 4 5 6 7 8 9  function prelude(REQUIRE_COMMON, VIRTUAL_FILESYSTEM, DEFAULT_ENTRYPOINT, SYMLINKS){ process.argv[1] = DEFAULT_ENTRYPOINT; // C:\\\\snapshot\\\\helloworld\\\\index.js  let ENTRYPOINT = process.argv[1]; Module.runMain = function runMain() { Module._load(ENTRYPOINT, null, true); process._tickCallback(); }; }   这样后续的 require(\u0026hellip;) 的文件路径都是相对于 C:\\\\snapshot\\\\helloworld\\\\index.js, 则都会到虚拟文件系统中查找。\n编译代码 在 pkg 中， 在打包阶段，可以先javascript代码编译成字节码，存储到虚拟文件系统；然后在运行阶段加载模块时就可以复用字节码了。\n在 prelude.js 中，修改了 Module.prototype._compile函数，在加载模块时复用字节码。\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39  Module.prototype._compile = function (content, filename_){ if (!insideSnapshot(filename_)) { return ancestor._compile.apply(this, arguments); } // 根据文件名读取虚拟文件系统元数据，例如:  // \u0026#34;C:\\\\snapshot\\\\helloworld\\\\index.js\u0026#34;: {  // \u0026#34;0\u0026#34;: [0, 656],  // \u0026#34;3\u0026#34;: [656, 118]  // }  const entity = findVirtualFileSystemEntry(filename_); const entityBlob = entity[STORE_BLOB]; const entityContent = entity[STORE_CONTENT]; if (entityBlob) { const options = { filename: filename_, lineOffset: 0, displayErrors: true, cachedData: payloadFileSync(entityBlob), // 从虚拟文件系统中读取字节码  sourceless: !entityContent, }; const code = entityContent ? Module.wrap(payloadFileSync(entityContent)) // 从虚拟文件系统中读取javascript代码， 主要是要保证code的长度与编译时的代码长度一致  : undefined; const script = new Script(code, options); const wrapper = script.runInThisContext(options); if (!wrapper) process.exit(4); // for example VERSION_MISMATCH  const dirname = path.dirname(filename_); const rqfn = makeRequireFunction(this); const args = [this.exports, rqfn, this, filename_, dirname]; return wrapper.apply(this.exports, args); } else { return ancestor._compile.apply(this, arguments); } }   将javascript代码编译成字节码 将javascript代码编译成字节码并不复杂，但需要注意的时，编译字节码用的node版本要和运行字节码用的版本要一致。\n例如，本机安装的node版本是10，需要打包的node版本是12，那么可以使用如下方式，使用 child_process.spawn 调用需要的打包的node二进制，这样编译字节码时用就是运行字节码的node二进制。\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77  const child_process = require(\u0026#34;child_process\u0026#34;); const script = ` var vm = require(\u0026#39;vm\u0026#39;); var module = require(\u0026#39;module\u0026#39;); var body = Buffer.alloc(0); process.stdin.on(\u0026#39;data\u0026#39;, function (data) { body = Buffer.concat([ body, data ]); }); process.stdin.on(\u0026#39;end\u0026#39;, function (data) { var code = module.wrap(body); var script = new vm.Script(code, { produceCachedData: true, sourceless: true }); if (!script.cachedDataProduced) { process.exit(2); } }); process.stdin.resume(); `; const code = \u0026#39;console.log(1)\u0026#39;; const cmd = \u0026#39;被打包的node二进制文件路径\u0026#39;; const child = child_process.spawn(cmd, [\u0026#39;-e\u0026#39;, script], { stdio: [\u0026#39;pipe\u0026#39;, \u0026#39;pipe\u0026#39;, process.stdout], }); function kill() { child.kill(); } function onClose(code) { removeListeners(); kill(); } function onError(error) { removeListeners(); kill(); } let bytecode = Buffer.alloc(0); function onData(data) { bytecode = Buffer.concat([bytecode, data]); } function onEnd() { saveByteCode(bytecode); } function removeListeners() { child.removeListener(\u0026#39;error\u0026#39;, onError); child.removeListener(\u0026#39;close\u0026#39;, onClose); child.stdin.removeListener(\u0026#39;error\u0026#39;, onError); child.stdout.removeListener(\u0026#39;error\u0026#39;, onError); child.stdout.removeListener(\u0026#39;data\u0026#39;, onData); child.stdout.removeListener(\u0026#39;end\u0026#39;, onEnd); } function addListeners() { child.on(\u0026#39;error\u0026#39;, onError); child.on(\u0026#39;close\u0026#39;, onClose); child.stdin.on(\u0026#39;error\u0026#39;, onError); child.stdout.on(\u0026#39;error\u0026#39;, onError); child.stdout.on(\u0026#39;data\u0026#39;, onData); child.stdout.on(\u0026#39;end\u0026#39;, onEnd); } addListeners(); let codeBuffer = Buffer.from(snap); child.stdin.write(codeBuffer);   ","description":"","id":3,"section":"posts","tags":null,"title":"Pkg原理","uri":"https://lulupy.github.io/posts/pkg%E5%B0%86node%E9%A1%B9%E7%9B%AE%E6%89%93%E5%8C%85%E6%88%90%E5%8F%AF%E6%89%A7%E8%A1%8C%E6%96%87%E4%BB%B6/content/pkg%E5%8E%9F%E7%90%86/"},{"content":"pkg 是一个命令行工具，可以帮我们把 node.js 脚本打包成可执行文件，直接在linux、mac、windows上运行，比如exe文件。\n比如我们希望打包 index.js 脚本:\n1 2  // index.js console.log(\u0026#39;hello world\u0026#39;);    安装  npm install -g pkg 打包成index.exe  pkg index.js -t node14-win-x64 --out-path out 运行index.exe  1 2 3  ./out/index.exe hello world   控制台打印出hello world\n","description":"","id":4,"section":"posts","tags":null,"title":"Pkg简介","uri":"https://lulupy.github.io/posts/pkg%E5%B0%86node%E9%A1%B9%E7%9B%AE%E6%89%93%E5%8C%85%E6%88%90%E5%8F%AF%E6%89%A7%E8%A1%8C%E6%96%87%E4%BB%B6/content/pkg%E7%AE%80%E4%BB%8B/"},{"content":"评论功能对一个博客来说是很重要的. 本文介绍如何为基于hugo构建的博客系统(使用了zzo主题)添加评论功能.\nzzo主题集成了多种评论系统, 稍作配置就可以使用. 本文重要介绍两种: utterances和valine. 因为这两种比较有代表性, 其他的都大同小异.\nutterances是基于GitHub issues的, valine是基于Leancloud.\n使用utterances  首先我们所需要的 github 仓库必须是公开的，而不是私有的，这样我们的读者才可以查看以及发表评论 我们必须在 github 上进行安装 utterances,首先我们访问 utterances应用程序 然后点击 Install 按钮进行安装 在这里可以选择可以关联的存储库，可以选择我们所拥有的库或者某一个仓库，这里我们只选择某一个需要进行评论的库，这样比较好 在hugo配置文件config/_default/params.toml中进行相关配置  1 2 3 4 5  [utterances] # https://utteranc.es/owner = \u0026#34;lulupy\u0026#34; # Your GitHub IDrepo = \u0026#34;lulupy.github.io\u0026#34; # The repo to store commentsmessage = \u0026#34;\u0026#34; # Optionallink = \u0026#34;\u0026#34; # Optional  然后代码上传只github page之后, 就可以看到评论区了:\n直接使用utterances 如果没有用hugo或者没有选择zzo主题, 直接使用也是很方便的, 只需要在你要使用评论的地方，插入以下代码:\n1 2 3 4 5 6 7 8 9  \u0026lt;script src=\u0026#34;https://utteranc.es/client.js\u0026#34; repo=\u0026#34;lulupy/lulupy.github.io\u0026#34; issue-term=\u0026#34;pathname\u0026#34; theme=\u0026#34;github-light\u0026#34; crossorigin=\u0026#34;anonymous\u0026#34; async \u0026gt; \u0026lt;/script\u0026gt;   当然, 上述过程1,2,3步依然需要配置的.\n使用valine Valine是一款基于Leancloud的快速、简洁且高效的评论系统.\n 创建LearnCloud应用, 选择开发版.  在 存储 -\u0026gt; 结构化数据 -\u0026gt; 创建Class 创建Comment数据库，用来存储评论数据  在 设置 -\u0026gt; 应用Keys中查看appId和appKey.  在hugo 配置文件config/_default/params.toml中配置valine  其中appId和appKey在第3步中获得.\n1 2 3 4 5 6 7 8 9  [valine]enable = trueappId = \u0026#39;xxx\u0026#39;appKey = \u0026#39;xxx\u0026#39;notify = false # mail notifier , https://github.com/xCss/Valine/wikiverify = false# Verification codeavatar = \u0026#39;mm\u0026#39; placeholder = \u0026#39;说点什么吧...\u0026#39;visitor = false  然后在页面上就可以看到评论区了:\n评论一条数据, 在leancloud上就可以看到这条数据了:\n","description":"","id":5,"section":"posts","tags":null,"title":"为博客添加评论功能","uri":"https://lulupy.github.io/posts/01/%E4%B8%BA%E5%8D%9A%E5%AE%A2%E6%B7%BB%E5%8A%A0%E8%AF%84%E8%AE%BA%E5%8A%9F%E8%83%BD/"},{"content":"Hugo是由Go语言实现的静态网站生成器. 类似的工具有很多, 比如hexo、jekyll, 为什么选择hugo? hexo比较容易上手，并且有很稳定、功能齐全的主题(比如Next). hugo目前还不太完善. 但相比于hexo, hugo的优势就是快. 根据相关博主提供的数据，他200篇左右的博文用Hexo 需要10分钟去生成静态网页，而Hugo 只需要10秒. 光这一点, 我就决定使用hugo.\n安装hugo 到 Hugo Releases 下载对应的操作系统版本的Hugo二进制文件\n我以MacOs系统为例.\n最好选择带extended版本的文件.\n1 2 3  tar -zxvf hugo_extended_0.82.1_macOS-64bit.tar.gz # 解压 cd hugo_extended_0.82.1_macOS-64bit mv hugo /usr/local/bin/ # 拷贝可执行文件到/usr/local/bin/   生成站点 1  hugo new site my-blog   站点目录结构:\n1 2 3 4 5 6 7 8 9  . ├── archetypes ├── config.toml ├── content ├── data ├── layouts ├── resources ├── static └── themes   创建文章 1 2  cd my-blog hugo new about.md   about.md 自动生成到了 content/about.md ，打开 about.md 看下:\n1 2 3 4 5 6 7  --- date: 2021-04-25T17:23:45+08:00 draft: true title: \u0026#34;about\u0026#34; --- 正文内容   使用皮肤 我选择的皮肤是zzo, 下载zzo到themes文件夹下:\n1 2 3  cd themes git clone https://github.com/zzossig/hugo-theme-zzo.git mv hugo-theme-zzo zzo # 改下名字   你必须保持如下文件结构, 否则程序将跑不起来. 详细内容请查看zzo configuration.\n1 2 3 4 5 6 7  root ├── config │ ├── _default │ │ ├── config.toml │ │ ├── languages.toml │ │ ├── menus.en.toml │ │ ├── params.toml   在config/_default/config.toml文件中设置theme:\n1  theme = \u0026#34;zzo\u0026#34;   在config/_default/params.toml文件中设置searchContent:\n1  searchContent = true # 在内容中搜索   如果不指定, 那就必须指定每篇文章的description, 否则页面js会报错, 导致搜索功能不可用.\n如果指定了searchContent = true, 生成的index.json就会包含content属性:\n1 2 3  [ { title: \u0026#39;\u0026#39;, description : \u0026#39;\u0026#39; ,content: \u0026#39;\u0026#39; }, ]   js的运行逻辑是如果description为空, 则运行obj.item.content.substring这么个语句, content为undefined则会报错.\n运行Hugo 在站点根目录执行 Hugo 命令进行调试:\n1  hugo server -D   浏览器里打开： http://localhost:1313\n-D: \u0026ndash;buildDrafts, 意思是draft: true的文件也会被构建.\n部署到GitHub Pages 首先在GitHub上创建一个名为lulupy.github.io的Repository. 将lulupy替换为你的github用户名.\n生成静态文件:\n1  hugo --baseUrl=\u0026#34;https://lulupy.github.io/\u0026#34;   注意: 以上命令并不会生成草稿页面\n所有静态页面都会生成到 public 目录, 将pubilc目录里所有文件 push 到刚创建的Repository的master分支:\n1 2 3 4 5 6  cd public git init git remote add origin https://github.com/lulupy/lulupy.github.io.git git add -A git commit -m \u0026#34;first commit\u0026#34; git push -u origin master   浏览器里访问：https://lulupy.github.io/\n","description":"","id":6,"section":"posts","tags":null,"title":"使用hugo搭建blog","uri":"https://lulupy.github.io/posts/01/%E4%BD%BF%E7%94%A8hugo%E6%90%AD%E5%BB%BAblog/"}]